import{r as e,o as n,c as t,a as s,F as a,b as i}from"./app.c32a0217.js";const r={},o=s("h1",{id:"liuli-util-i18next-dts-gen",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#liuli-util-i18next-dts-gen","aria-hidden":"true"},"#"),i(" @liuli-util/i18next-dts-gen")],-1),l=s("h2",{id:"introduction",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#introduction","aria-hidden":"true"},"#"),i(" Introduction")],-1),p=s("p",null,"i18next's typescript type definition generator can generate type definitions from multiple language translation json files, supporting nested objects and parameters.",-1),c=s("h2",{id:"use",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#use","aria-hidden":"true"},"#"),i(" Use")],-1),u=s("blockquote",null,[s("p",null,"The type definition generation of the international configuration of cli itself is also done by cli (bootstrapping)")],-1),d=s("div",{class:"language-bash ext-sh line-numbers-mode"},[s("pre",{class:"language-bash"},[s("code",null,[i("i18next-dts-gen --input src/i18n "),s("span",{class:"token comment"},"# Scan this directory for json files and generate index.d.ts type definitions"),i("\n")])]),s("div",{class:"line-numbers"},[s("span",{class:"line-number"},"1"),s("br")])],-1),h=s("p",null,"Detail",-1),f=s("div",{class:"language-bash ext-sh line-numbers-mode"},[s("pre",{class:"language-bash"},[s("code",null,[i("$ i18next-dts-gen -h\nUsage: bin "),s("span",{class:"token punctuation"},"["),i("options"),s("span",{class:"token punctuation"},"]"),i("\n\nGenerate .d.ts "),s("span",{class:"token builtin class-name"},"type"),i(" definitions from json\n\nOptions:\n  -i, --input "),s("span",{class:"token operator"},"<"),i("input"),s("span",{class:"token punctuation"},".."),i("."),s("span",{class:"token operator"},">"),i("  Directory containing one or "),s("span",{class:"token function"},"more"),i(" translation files\n  -w, --watch             Whether to use "),s("span",{class:"token function"},"watch"),i(" mode\n  -h, --help              display "),s("span",{class:"token builtin class-name"},"help"),i(),s("span",{class:"token keyword"},"for"),i(),s("span",{class:"token builtin class-name"},"command"),i("\n")])]),s("div",{class:"line-numbers"},[s("span",{class:"line-number"},"1"),s("br"),s("span",{class:"line-number"},"2"),s("br"),s("span",{class:"line-number"},"3"),s("br"),s("span",{class:"line-number"},"4"),s("br"),s("span",{class:"line-number"},"5"),s("br"),s("span",{class:"line-number"},"6"),s("br"),s("span",{class:"line-number"},"7"),s("br"),s("span",{class:"line-number"},"8"),s("br"),s("span",{class:"line-number"},"9"),s("br")])],-1),b=s("h2",{id:"motivation",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#motivation","aria-hidden":"true"},"#"),i(" Motivation")],-1),m=s("p",null,"Why should I write this when there are already many third-party type definition generators, and even the latest version of i18next has an official typescript solution?",-1),g=s("p",null,"In short, they are not perfect.",-1),y=s("p",null,"Let's start with the official i18next solution, which replaces json files with ts files, but does not support parameters and nested objects.",-1),x=s("p",null,"Note: The latest version seems to take advantage of typescript 4.2's recursive types and template string types for type safety, but this doesn't actually work very well. Also only react-i18next is available.",-1),k={href:"https://react.i18next.com/latest/typescript",target:"_blank",rel:"noopener noreferrer"},v=i("i18next typescript support"),w={href:"https://stackoverflow.com/questions/58277973/how-to-type-check-i18n-dictionaries-with-typescript",target:"_blank",rel:"noopener noreferrer"},j=i("StackOverflow type definition for i18next"),I=i(" /58308279#58308279)"),q=i("Then "),A={href:"https://github.com/LFDM/i18next-typescript",target:"_blank",rel:"noopener noreferrer"},D=i("i18next-typescript"),O=i(", a third-party library, almost meets my needs, except for one thing: support for object parameters. There is also something like Jack Chicory's "),T={href:"https://github.com/Jack-Works/i18n-codegen",target:"_blank",rel:"noopener noreferrer"},_=i("i18n-codegen"),F=i(", which is very elegant in code design, but again, does not support ecologies other than react."),L=s("p",null,"Also, as far as I'm concerned, I think it's easier and more reasonable to use generators to generate simple types than to support such features from the type system.",-1),N=s("h2",{id:"design",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#design","aria-hidden":"true"},"#"),i(" Design")],-1),W=s("p",null,[s("img",{src:"/assets/schema.drawio.57ab7d39.svg",alt:"schema"}),s("img",{src:"/assets/flowchart.drawio.8b041b79.svg",alt:"flowchart"})],-1),C=s("h2",{id:"faq",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#faq","aria-hidden":"true"},"#"),i(" FAQ")],-1),G=s("h3",{id:"are-all-features-of-i18next-supported",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#are-all-features-of-i18next-supported","aria-hidden":"true"},"#"),i(" Are all features of i18next supported?")],-1),J=s("p",null,"No, only a subset of i18next is supported here.",-1),M=s("ul",null,[s("li",null,"[x] Generate type definitions for multiple localized json profiles"),s("li",null,[i("[x] Include parameters are supported "),s("ul",null,[s("li",null,"[ ] Object parameters are not supported")])]),s("li",null,"[x] Nested keys are supported"),s("li",null,"[ ] does not support configuration namespaces, nested split strings, and we consider conventions over configuration"),s("li",null,"[ ] Configuration files other than json are not supported, we believe json files are more friendly to non-developers and easier for developers to handle when needed"),s("li",null,"[ ] i18next namespaces are not supported, i.e. translation file splitting")],-1);r.render=function(i,r){const S=e("OutboundLink");return n(),t(a,null,[o,l,p,c,u,d,h,f,b,m,g,y,s("blockquote",null,[x,s("ul",null,[s("li",null,[s("a",k,[v,s(S)])]),s("li",null,[s("a",w,[j,s(S)]),I])])]),s("p",null,[q,s("a",A,[D,s(S)]),O,s("a",T,[_,s(S)]),F]),L,N,W,C,G,J,M],64)};export default r;
